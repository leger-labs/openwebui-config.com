/**
 * Output Formatter Module
 * 
 * This module takes the generated component mappings and formats them into a production-ready
 * TypeScript file. The key principle here is to create code that feels hand-written rather
 * than machine-generated - well-organized, properly documented, and easy to use.
 * 
 * The output includes:
 * - Complete component mapping registry with TypeScript types
 * - Component props derived from field constraints
 * - Wrapper component requirements
 * - Utility functions for runtime component selection
 * - Integration metadata for react-ts-form
 * 
 * Think of this as the final assembly step that takes all our intelligent decisions and
 * packages them into a form that developers can easily consume.
 */

/**
 * Format the component mappings into TypeScript output
 * This is the main entry point that orchestrates the entire formatting process.
 * 
 * @param {object} mappingResults - Results from the mapping generator
 * @param {object} schemaData - Original schema data for reference
 * @returns {Promise<string>} Formatted TypeScript file content
 */
export async function formatOutput(mappingResults, schemaData) {
  console.log('Formatting component mappings into TypeScript output...');
  
  const { mappings, statistics, metadata } = mappingResults;
  
  // Generate the complete TypeScript content
  const content = generateTypeScriptContent(mappings, statistics, metadata, schemaData);
  
  // Format with prettier if available
  let formattedContent = content;
  
  try {
    const prettier = await import('prettier');
    const options = {
      parser: 'typescript',
      printWidth: 100,
      tabWidth: 2,
      semi: true,
      singleQuote: true,
      trailingComma: 'all',
      bracketSpacing: true,
      arrowParens: 'avoid'
    };
    
    formattedContent = await prettier.default.format(content, options);
    console.log('✓ Formatted output with prettier');
  } catch (error) {
    console.warn('⚠️  Could not format with prettier, using unformatted output:', error.message);
  }
  
  return formattedContent;
}

/**
 * Generate the complete TypeScript file content
 * This function orchestrates all the different sections of the output file.
 * 
 * @param {object} mappings - Component mappings
 * @param {object} statistics - Mapping statistics
 * @param {object} metadata - Generation metadata
 * @param {object} schemaData - Original schema data
 * @returns {string} Complete TypeScript file content
 */
function generateTypeScriptContent(mappings, statistics, metadata, schemaData) {
  const sections = [];
  
  // File header with comprehensive documentation
  sections.push(generateFileHeader(metadata, statistics));
  
  // TypeScript type definitions
  sections.push(generateTypeDefinitions());
  
  // Component mapping registry
  sections.push(generateComponentMappingRegistry(mappings));
  
  // Component props registry
  sections.push(generateComponentPropsRegistry(mappings));
  
  // Wrapper components registry
  sections.push(generateWrapperRegistry(mappings));
  
  // Integration metadata for react-ts-form
  sections.push(generateIntegrationMetadata(mappings, statistics, schemaData));
  
  // Utility functions for runtime usage
  sections.push(generateUtilityFunctions());
  
  // Main export combining everything
  sections.push(generateMainExport(metadata));
  
  return sections.join('\n\n');
}

/**
 * Generate the file header with comprehensive documentation
 * This creates a clear explanation of what the file contains and how it was generated.
 * 
 * @param {object} metadata - Generation metadata
 * @param {object} statistics - Mapping statistics
 * @returns {string} File header content
 */
function generateFileHeader(metadata, statistics) {
  return `/**
 * Generated Component Mappings for OpenWebUI Configuration Forms
 * DO NOT EDIT DIRECTLY - Changes will be overwritten
 * 
 * This file contains the complete component mapping registry generated by applying
 * declarative design rules to field characteristics from the OpenAPI schema and uiSchema.
 * 
 * The component mappings define which React components should be used for each
 * configuration field, along with their props, wrappers, and alternatives.
 * 
 * Generated at: ${metadata.generatedAt}
 * Total fields processed: ${metadata.totalFields}
 * 
 * Component Assignment Statistics:
 * - Rule-based assignments: ${statistics.ruleBasedAssignments}
 * - Explicit overrides: ${statistics.ruleEffectiveness.explicitOverrides}
 * - Pattern matches: ${statistics.ruleEffectiveness.patternMatches}
 * - uiSchema suggestions: ${statistics.ruleEffectiveness.uiSchemaSuggestions}
 * - Type defaults: ${statistics.ruleEffectiveness.typeDefaults}
 * - Fallbacks: ${statistics.ruleEffectiveness.fallbacks}
 * 
 * Components used: ${Object.keys(statistics.componentUsage).join(', ')}
 * 
 * Architecture Notes:
 * - Component selection follows declarative design rules rather than algorithmic inference
 * - Explicit field overrides take precedence over pattern rules and type defaults
 * - Component props are derived from field constraints and validation rules
 * - Wrapper components add functionality like conditional visibility and premium features
 * - Alternative components are provided for progressive enhancement and A/B testing
 * 
 * Usage:
 * import { getComponentForField, getComponentProps, componentMappings } from './generated-component-mapping';
 * 
 * const component = getComponentForField('OPENAI_API_KEY'); // 'secret-field'
 * const props = getComponentProps('OPENAI_API_KEY'); // { type: 'password', autoComplete: 'new-password' }
 */`;
}

/**
 * Generate TypeScript type definitions
 * These types ensure type safety when using the component mappings.
 * 
 * @returns {string} Type definitions section
 */
function generateTypeDefinitions() {
  return `// Core type definitions for component mappings

/**
 * Represents a complete component mapping for a single field
 */
export interface ComponentMapping {
  /** Primary component to use for this field */
  component: string;
  
  /** Props to pass to the component */
  props: Record<string, any>;
  
  /** Wrapper components that should wrap this field */
  wrappers: string[];
  
  /** Alternative components that could be used instead */
  alternatives: string[];
  
  /** Decision path showing how this component was selected */
  decisionPath: string[];
  
  /** Human-readable reason for this component choice */
  decisionReason: string;
}

/**
 * Component props specific to different field types
 */
export interface ComponentProps {
  /** Basic HTML input props */
  type?: string;
  placeholder?: string;
  autoComplete?: string;
  
  /** Validation constraints */
  minLength?: number;
  maxLength?: number;
  min?: number;
  max?: number;
  pattern?: string;
  
  /** Select field options */
  options?: Array<{ value: any; label: string }>;
  
  /** Rich text editor props */
  rows?: number;
  
  /** Field metadata */
  description?: string;
  conditional?: boolean;
}

/**
 * Available shadcn form components
 */
export type AvailableComponent = 
  | 'text-field'
  | 'secret-field'
  | 'select-field'
  | 'toggle-field'
  | 'url-input'
  | 'array-field'
  | 'markdown-text-area';

/**
 * Available wrapper components
 */
export type AvailableWrapper =
  | 'conditional-field'
  | 'overrideable-field'
  | 'plan-restricted-feature';

/**
 * Component registry mapping field names to their component configurations
 */
export type ComponentRegistry = Record<string, ComponentMapping>;

/**
 * Integration metadata for framework compatibility
 */
export interface IntegrationMetadata {
  /** react-ts-form compatibility information */
  reactTsForm: {
    compatible: boolean;
    totalFields: number;
    mappedFields: number;
    conditionalFields: number;
  };
  
  /** Component library information */
  componentLibrary: {
    name: string;
    components: string[];
    wrappers: string[];
  };
  
  /** Generation statistics */
  statistics: {
    totalFields: number;
    componentTypes: number;
    ruleBasedAssignments: number;
    coverage: number;
  };
}

/**
 * Main export interface combining all component mapping data
 */
export interface OpenWebUIComponentMappings {
  /** Component mappings for all fields */
  mappings: ComponentRegistry;
  
  /** Component props organized by field */
  props: Record<string, ComponentProps>;
  
  /** Wrapper requirements organized by field */
  wrappers: Record<string, string[]>;
  
  /** Integration metadata */
  integration: IntegrationMetadata;
  
  /** Generation metadata */
  metadata: {
    generatedAt: string;
    totalFields: number;
    version: string;
  };
}`;
}

/**
 * Generate the component mapping registry
 * This is the core data structure that maps each field to its component.
 * 
 * @param {object} mappings - Component mappings from the generator
 * @returns {string} Component mapping registry code
 */
function generateComponentMappingRegistry(mappings) {
  // Sort fields alphabetically for better organization
  const sortedFields = Object.keys(mappings).sort();
  
  // Split into chunks to avoid very long object literals
  const fieldsPerChunk = 50;
  const chunks = [];
  
  for (let i = 0; i < sortedFields.length; i += fieldsPerChunk) {
    const chunkFields = sortedFields.slice(i, i + fieldsPerChunk);
    const chunkMappings = {};
    
    chunkFields.forEach(fieldName => {
      chunkMappings[fieldName] = mappings[fieldName];
    });
    
    chunks.push(chunkMappings);
  }
  
  let code = '// Component Mapping Registry - Maps each field to its component configuration\n';
  
  chunks.forEach((chunk, index) => {
    code += `const componentMappingsPart${index + 1}: Record<string, ComponentMapping> = ${JSON.stringify(chunk, null, 2)} as const;\n\n`;
  });
  
  code += `/**
 * Complete component mappings for all configuration fields
 * This registry contains the definitive component assignment for each field
 */
export const componentMappings: ComponentRegistry = {
  ${chunks.map((_, index) => `...componentMappingsPart${index + 1}`).join(',\n  ')}
} as const;`;
  
  return code;
}

/**
 * Generate the component props registry
 * This extracts just the props for easier access during form rendering.
 * 
 * @param {object} mappings - Component mappings from the generator
 * @returns {string} Component props registry code
 */
function generateComponentPropsRegistry(mappings) {
  const propsRegistry = {};
  
  Object.entries(mappings).forEach(([fieldName, mapping]) => {
    if (mapping.props && Object.keys(mapping.props).length > 0) {
      propsRegistry[fieldName] = mapping.props;
    }
  });
  
  return `// Component Props Registry - Extracted props for each field's component
export const componentProps: Record<string, ComponentProps> = ${JSON.stringify(propsRegistry, null, 2)} as const;`;
}

/**
 * Generate the wrapper registry
 * This organizes wrapper component requirements for easy access.
 * 
 * @param {object} mappings - Component mappings from the generator
 * @returns {string} Wrapper registry code
 */
function generateWrapperRegistry(mappings) {
  const wrapperRegistry = {};
  
  Object.entries(mappings).forEach(([fieldName, mapping]) => {
    if (mapping.wrappers && mapping.wrappers.length > 0) {
      wrapperRegistry[fieldName] = mapping.wrappers;
    }
  });
  
  return `// Wrapper Components Registry - Wrapper requirements for each field
export const fieldWrappers: Record<string, string[]> = ${JSON.stringify(wrapperRegistry, null, 2)} as const;`;
}

/**
 * Generate integration metadata
 * This provides information needed for framework integration.
 * 
 * @param {object} mappings - Component mappings
 * @param {object} statistics - Mapping statistics
 * @param {object} schemaData - Original schema data
 * @returns {string} Integration metadata code
 */
function generateIntegrationMetadata(mappings, statistics, schemaData) {
  const conditionalFields = Object.values(mappings).filter(m => m.props?.conditional).length;
  
  const integrationMetadata = {
    reactTsForm: {
      compatible: true,
      totalFields: statistics.totalFields,
      mappedFields: Object.keys(mappings).length,
      conditionalFields: conditionalFields
    },
    componentLibrary: {
      name: 'shadcn/ui',
      components: Object.keys(statistics.componentUsage),
      wrappers: Object.keys(statistics.wrapperUsage || {})
    },
    statistics: {
      totalFields: statistics.totalFields,
      componentTypes: statistics.uniqueComponents,
      ruleBasedAssignments: statistics.ruleBasedAssignments,
      coverage: Math.round((Object.keys(mappings).length / statistics.totalFields) * 100)
    }
  };
  
  return `// Integration Metadata - Information for framework compatibility
export const integrationMetadata: IntegrationMetadata = ${JSON.stringify(integrationMetadata, null, 2)} as const;`;
}

/**
 * Generate utility functions
 * These functions provide convenient access to the component mappings at runtime.
 * 
 * @returns {string} Utility functions code
 */
function generateUtilityFunctions() {
  return `// Utility Functions - Convenient access to component mappings

/**
 * Get the component name for a specific field
 * @param fieldName - Name of the configuration field
 * @returns Component name or 'text-field' as default
 */
export function getComponentForField(fieldName: string): AvailableComponent {
  const mapping = componentMappings[fieldName];
  return (mapping?.component as AvailableComponent) || 'text-field';
}

/**
 * Get the component props for a specific field
 * @param fieldName - Name of the configuration field
 * @returns Props object for the component
 */
export function getComponentProps(fieldName: string): ComponentProps {
  return componentProps[fieldName] || {};
}

/**
 * Get the wrapper components for a specific field
 * @param fieldName - Name of the configuration field
 * @returns Array of wrapper component names
 */
export function getFieldWrappers(fieldName: string): AvailableWrapper[] {
  return (fieldWrappers[fieldName] as AvailableWrapper[]) || [];
}

/**
 * Get alternative components for a specific field
 * @param fieldName - Name of the configuration field
 * @returns Array of alternative component names
 */
export function getAlternativeComponents(fieldName: string): AvailableComponent[] {
  const mapping = componentMappings[fieldName];
  return (mapping?.alternatives as AvailableComponent[]) || [];
}

/**
 * Check if a field requires conditional rendering
 * @param fieldName - Name of the configuration field
 * @returns True if the field has conditional logic
 */
export function isConditionalField(fieldName: string): boolean {
  const props = getComponentProps(fieldName);
  return Boolean(props.conditional);
}

/**
 * Check if a field requires premium access (plan-restricted)
 * @param fieldName - Name of the configuration field
 * @returns True if the field requires premium access
 */
export function isPremiumField(fieldName: string): boolean {
  const wrappers = getFieldWrappers(fieldName);
  return wrappers.includes('plan-restricted-feature');
}

/**
 * Get all fields using a specific component
 * @param componentName - Name of the component to search for
 * @returns Array of field names using this component
 */
export function getFieldsUsingComponent(componentName: string): string[] {
  return Object.keys(componentMappings).filter(fieldName => {
    return componentMappings[fieldName].component === componentName;
  });
}

/**
 * Get component usage statistics
 * @returns Object with component usage counts
 */
export function getComponentUsageStats(): Record<string, number> {
  const usage: Record<string, number> = {};
  
  Object.values(componentMappings).forEach(mapping => {
    const component = mapping.component;
    usage[component] = (usage[component] || 0) + 1;
  });
  
  return usage;
}

/**
 * Get fields by category (if category information is available)
 * @param categoryName - Name of the category
 * @returns Array of field names in this category
 */
export function getFieldsByCategory(categoryName: string): string[] {
  // Note: This would require category information from uiSchema
  // For now, return empty array - can be enhanced when category data is needed
  return [];
}

/**
 * Validate that a component mapping exists for a field
 * @param fieldName - Name of the configuration field
 * @returns True if mapping exists, false otherwise
 */
export function hasComponentMapping(fieldName: string): boolean {
  return Boolean(componentMappings[fieldName]);
}

/**
 * Get the decision path for how a component was selected
 * @param fieldName - Name of the configuration field
 * @returns Array of decision steps or empty array if no mapping
 */
export function getComponentDecisionPath(fieldName: string): string[] {
  const mapping = componentMappings[fieldName];
  return mapping?.decisionPath || [];
}

/**
 * Get human-readable explanation for component choice
 * @param fieldName - Name of the configuration field
 * @returns Explanation string or empty string if no mapping
 */
export function getComponentDecisionReason(fieldName: string): string {
  const mapping = componentMappings[fieldName];
  return mapping?.decisionReason || '';
}

/**
 * Create a component configuration object for react-ts-form
 * @param fieldName - Name of the configuration field
 * @returns Configuration object ready for react-ts-form
 */
export function createReactTsFormConfig(fieldName: string) {
  const component = getComponentForField(fieldName);
  const props = getComponentProps(fieldName);
  const wrappers = getFieldWrappers(fieldName);
  
  return {
    component,
    props,
    wrappers,
    // Add any additional react-ts-form specific configuration here
  };
}

/**
 * Validate all component mappings
 * @returns Validation result with any issues found
 */
export function validateComponentMappings(): { valid: boolean; issues: string[] } {
  const issues: string[] = [];
  
  // Check for missing mappings
  // This would require knowledge of all expected fields from the schema
  
  // Check for invalid component references
  const validComponents: AvailableComponent[] = [
    'text-field', 'secret-field', 'select-field', 'toggle-field',
    'url-input', 'array-field', 'markdown-text-area'
  ];
  
  Object.entries(componentMappings).forEach(([fieldName, mapping]) => {
    if (!validComponents.includes(mapping.component as AvailableComponent)) {
      issues.push(\`Field '\${fieldName}' has invalid component '\${mapping.component}'\`);
    }
  });
  
  return {
    valid: issues.length === 0,
    issues
  };
}`;
}

/**
 * Generate the main export
 * This combines all the pieces into a single exportable object.
 * 
 * @param {object} metadata - Generation metadata
 * @returns {string} Main export code
 */
function generateMainExport(metadata) {
  return `// Main Export - Complete component mapping system
export const openWebUIComponentMappings: OpenWebUIComponentMappings = {
  mappings: componentMappings,
  props: componentProps,
  wrappers: fieldWrappers,
  integration: integrationMetadata,
  metadata: {
    generatedAt: '${metadata.generatedAt}',
    totalFields: ${metadata.totalFields},
    version: '1.0.0'
  }
} as const;

// Default export for convenience
export default openWebUIComponentMappings;`;
}
